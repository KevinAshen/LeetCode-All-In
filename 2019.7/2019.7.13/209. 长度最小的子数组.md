[TOC]
## é¢˜ç›®

1. - ç»™å®šä¸€ä¸ªå«æœ‰ n ä¸ªæ­£æ•´æ•°çš„æ•°ç»„å’Œä¸€ä¸ªæ­£æ•´æ•° s ï¼Œæ‰¾å‡ºè¯¥æ•°ç»„ä¸­æ»¡è¶³å…¶å’Œ â‰¥ s çš„é•¿åº¦æœ€å°çš„è¿ç»­å­æ•°ç»„ã€‚å¦‚æœä¸å­˜åœ¨ç¬¦åˆæ¡ä»¶çš„è¿ç»­å­æ•°ç»„ï¼Œè¿”å› 0ã€‚

     ç¤ºä¾‹: 

     è¾“å…¥: s = 7, nums = [2,3,1,2,4,3]
è¾“å‡º: 2
     è§£é‡Š: å­æ•°ç»„ [4,3] æ˜¯è¯¥æ¡ä»¶ä¸‹çš„é•¿åº¦æœ€å°çš„è¿ç»­å­æ•°ç»„ã€‚
   è¿›é˜¶:
     
     å¦‚æœä½ å·²ç»å®Œæˆäº†O(n) æ—¶é—´å¤æ‚åº¦çš„è§£æ³•, è¯·å°è¯• O(n log n) æ—¶é—´å¤æ‚åº¦çš„è§£æ³•ã€‚
     
     
     
     æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
     é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/minimum-size-subarray-sum
     è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
     
## å‚è€ƒæ–‡ç« 

- [[LeetCode\] Minimum Size Subarray Sum æœ€çŸ­å­æ•°ç»„ä¹‹å’Œ](https://www.cnblogs.com/grandyang/p/4501934.html)

***
## é¢˜è§£

### æˆ‘çš„é¢˜è§£

```c++
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int n = nums.size();
        int left = 0, right = 0;
        int res = INT_MAX;
        vector<int> dp(n, 0);
        if (nums.empty()) {
            return 0;
        }
        if (nums[0] >= s) {
            return 1;
        }
        int sum = 0;
        for (int i = 0; i < n; i++) {
            sum += nums[i];
            dp[i] = sum;
            if (sum >= s) {
                //if (i == n - 1) {
                //    return i + 1;
                //} else {
                    right = i;
                    res = right + 1;
                    break; 
               // }
            }
        }
        if (sum < s) {
            return 0;
        }
        
        
        dp[right] = sum;
        //right++;
        for (; right < n; right++) {
            sum = dp[right - 1] + nums[right];
            while(1) {
                if ((sum - nums[left]) < s) {
                    break;
                } else {
                    sum -= nums[left];
                    left++;
                }
            }
            dp[right] = sum;
            res = min(res, right - left + 1);
        }
        return res;
    }
};
```

***
### å‚è€ƒé¢˜è§£
```c++
// O(n)
//è¿™ä¸ªåšæ³•è·Ÿæˆ‘å·®ä¸å¤šï¼Œå°±æ˜¯ä¸­å’Œäº†æˆ‘å¾ˆå¤šç‰¹æ®Šæƒ…å†µï¼ŒğŸ˜‚
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        if (nums.empty()) return 0;
        int left = 0, right = 0, sum = 0, len = nums.size(), res = len + 1;
        while (right < len) {
            while (sum < s && right < len) {
                sum += nums[right++];
            }
            while (sum >= s) {
                res = min(res, right - left);
                sum -= nums[left++];
            }
        }
        return res == len + 1 ? 0 : res;
    }
};

// O(nlgn)
//æ„Ÿè§‰è¿˜æ˜¯å¯¹äºŒåˆ†äº†è§£ä¸åˆ°ä½ï¼Œå¥½æ¶ˆæ¯æ˜¯ç¡®å®lognæƒ³åˆ°äºŒåˆ†
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int len = nums.size(), sums[len + 1] = {0}, res = len + 1;
        for (int i = 1; i < len + 1; ++i) sums[i] = sums[i - 1] + nums[i - 1];
        for (int i = 0; i < len + 1; ++i) {
            int right = searchRight(i + 1, len, sums[i] + s, sums);
            if (right == len + 1) break;
            if (res > right - i) res = right - i;
        }
        return res == len + 1 ? 0 : res;
    }
    int searchRight(int left, int right, int key, int sums[]) {
        while (left <= right) {
            int mid = (left + right) / 2;
            if (sums[mid] >= key) right = mid - 1;
            else left = mid + 1;
        }
        return left;
    }
};
```


## åæ€

æˆ‘ä½›äº† äºŒåˆ†å¤ªéš¾æ‡‚äº†å§ éœ€è¦å¥½å¥½ç ”ç©¶ä¸‹

