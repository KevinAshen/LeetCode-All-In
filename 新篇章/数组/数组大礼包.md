[TOC]
# 167. 两数之和 II - 输入有序数组
## 题目
给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。
函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。
说明:
返回的下标值（index1 和 index2）不是从零开始的。
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
示例:
输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。  

## 参考文章

- [LeetCode\] Two Sum II - Input array is sorted 两数之和之二 - 输入数组有序](https://www.cnblogs.com/grandyang/p/5185815.html)

***
## 题解

### 我的题解

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int size = numbers.size();
        if (size == 0 || size == 1) {
            return {};
        }
        int left = 0, right = size - 1;
        int sum = numbers[left] + numbers[right];
        while (sum != target) {
            while (sum < target) {
                left++;
                sum = numbers[left] + numbers[right];
            }
            while (sum > target) {
                right--;
                sum = numbers[left] + numbers[right];
            }
        }
        return {left + 1, right + 1};
    }
};
```

***
### 参考题解
```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int size = numbers.size();
        if (size == 0 || size == 1) {
            return {};
        }
        int left = 0, right = size - 1;
        int sum = numbers[left] + numbers[right];
        while (sum != target) {
            while (sum < target) {
                left++;
                sum = numbers[left] + numbers[right];
            }
            while (sum > target) {
                right--;
                sum = numbers[left] + numbers[right];
            }
        }
        return {left + 1, right + 1};
    }
};
```
## 反思
easy

# 216. 组合总和 III

## 题目

找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

说明：

所有数字都是正整数。
解集不能包含重复的组合。 
示例 1:

输入: k = 3, n = 7
输出: [[1,2,4]]
示例 2:

输入: k = 3, n = 9
输出: [[1,2,6], [1,3,5], [2,3,4]]

## 参考文章

- [LeetCode\] Combination Sum III 组合之和之三](https://www.cnblogs.com/grandyang/p/4537983.html)
***
## 题解
### 我的题解

```c++
class Solution {
public:
    void DFS(vector<vector<int>> &res, int target, int start, vector<int> out, int num) {
        if (target == 0 && num == 0) {
            res.push_back(out);
            return;
        }
        if (target < 0 || num < 0) {
            return;
        }
        
        for (int i = start; i < 10; i++) {
            out.push_back(i);
            DFS(res, target - i, i + 1, out, num - 1);
            out.pop_back();
        }
    }
    
    vector<vector<int>> combinationSum3(int k, int n) {
        vector<vector<int>> res;
        if (k > 9) {
            return res;
        }
        DFS(res, n, 1, {}, k);
        return res;
    }
};
```

***
### 参考题解
```c++
class Solution {
public:
    vector<vector<int> > combinationSum3(int k, int n) {
        vector<vector<int> > res;
        vector<int> out;
        combinationSum3DFS(k, n, 1, out, res);
        return res;
    }
    void combinationSum3DFS(int k, int n, int level, vector<int> &out, vector<vector<int> > &res) {
        if (n < 0) return;
        if (n == 0 && out.size() == k) res.push_back(out);
        for (int i = level; i <= 9; ++i) {
            out.push_back(i);
            combinationSum3DFS(k, n - i, i + 1, out, res);
            out.pop_back();
        }
    }
};
```
## 反思
# 169. 求众数
## 题目
给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在众数。

示例 1:

输入: [3,2,3]
输出: 3
示例 2:

输入: [2,2,1,1,1,2,2]
输出: 2
## 参考文章
- [[LeetCode] Majority Element 求大多数
](https://www.cnblogs.com/grandyang/p/4233501.html)
***
## 题解
### 我的题解
```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        if (nums.empty()) {
            return -1;
        }
        sort(nums.begin(), nums.end());
        int length = nums.size();
        int left = 0, right = length - 1;
        int mid = left + (right - left) / 2;
        return nums[mid];
    }
};
```

***
### 参考题解
```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int res = 0, cnt = 0;
        for (int num : nums) {
            if (cnt == 0) {res = num; ++cnt;}
            else (num == res) ? ++cnt : --cnt;
        }
        return res;
    }
};

class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int res = 0, n = nums.size();
        for (int i = 0; i < 32; ++i) {
            int ones = 0, zeros = 0;
            for (int num : nums) {
                if (ones > n / 2 || zeros > n / 2) break;
                if ((num & (1 << i)) != 0) ++ones;
                else ++zeros;
            }
            if (ones > zeros) res |= (1 << i);
        }
        return res;
    }
};
```
## 反思

- 摩尔投票法，实用计数器处理
- 我的做法只要O1就行了，竟然只超过一半的人，剩下都是什么玩意
- 位操作有点东西
# 229. 求众数 II
## 题目
给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。

说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。

示例 1:

输入: [3,2,3]
输出: [3]
示例 2:

输入: [1,1,1,3,3,2,2,2]
输出: [1,2]
## 参考文章

- [[LeetCode\] Majority Element II 求大多数之二](https://www.cnblogs.com/grandyang/p/4606822.html)
***
## 题解
### 我的题解
```c++
class Solution {
public:
    vector<int> majorityElement(vector<int>& nums) {
        if (nums.empty()) {
            return {};
        }
        if (nums.size() == 1) {
            return {nums[0]};
        }
        vector<int> res;
        int n = nums.size();
        int m = n / 3;
        int num = nums[0], count = 1;
        sort(nums.begin(), nums.end());
        nums.push_back(-1000);
        for (int i = 1; i < n + 1; i++) {
            if (nums[i] == nums[i - 1]) {
                count++;
            } else {
                if (count >= m) {
                    res.push_back(num);
                }
                num = nums[i];
                count = 1;
            }
        }
        return res;
    }
};
```

***
### 参考题解
```c++
class Solution {
public:
    vector<int> majorityElement(vector<int>& nums) {
        vector<int> res;
        int a = 0, b = 0, cnt1 = 0, cnt2 = 0, n = nums.size();
        for (int num : nums) {
            if (num == a) ++cnt1;
            else if (num == b) ++cnt2;
            else if (cnt1 == 0) { a = num; cnt1 = 1; }
            else if (cnt2 == 0) { b = num; cnt2 = 1; }
            else { --cnt1; --cnt2; }
        }
        cnt1 = cnt2 = 0;
        for (int num : nums) {
            if (num == a) ++cnt1;
            else if (num == b) ++cnt2;
        }
        if (cnt1 > n / 3) res.push_back(a);
        if (cnt2 > n / 3) res.push_back(b);
        return res;
    }
};
```
## 反思
- 佛了，还是数学问题呀，大于三分之一的最多有两个还行
# 189. 旋转数组
## 题目

给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

示例 1:

输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
示例 2:

输入: [-1,-100,3,99] 和 k = 2
输出: [3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
说明:

尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
要求使用空间复杂度为 O(1) 的 原地 算法。

## 参考文章
- [[LeetCode] 189. Rotate Array 旋转数组](https://www.cnblogs.com/grandyang/p/4298711.html)
***
## 题解
### 我的题解
```c++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int len = nums.size();
        if (len == 0 || (K %= len) == 0 || len == 1) {
            return;
        }
        int t = len;
        int start = 0, idx = 0, pre = 0, cur = nums[0];
        while (t--) {
            //pre：准备进行赋值的数据的数据
            //idx：下一个被赋值的下标
            //cur：保存idx上的原数据，也是下一个pre
            //strat：防止死循环
            pre = cur;
            idx = (idx + k) % n;
            cur = nums[idx];
            nums[idx] = pre;
            if (idx == start) {
                idx == ++start;
                cur = nums[idx];
            }
        }
        return;
    }
};
```

***
### 参考题解
```c++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        if (nums.empty()) return;
        int n = nums.size(), start = 0;   
        while (n && (k %= n)) {
            for (int i = 0; i < k; ++i) {
                swap(nums[i + start], nums[n - k + i + start]);
            }
            n -= k;
            start += k;
        }
    }
};

class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        if (nums.empty() || (k %= nums.size()) == 0) return;
        int n = nums.size();
        for (int i = 0; i < n - k; ++i) {
            nums.push_back(nums[0]);
            nums.erase(nums.begin());
        }
    }
};

class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        if (nums.empty() || (k %= nums.size()) == 0) return;
        int n = nums.size();
        reverse(nums.begin(), nums.begin() + n - k);
        reverse(nums.begin() + n - k, nums.end());
        reverse(nums.begin(), nums.end());
    }
};
```
## 反思
- 巨菜

# 228. 汇总区间

## 题目

给定一个无重复元素的有序整数数组，返回数组区间范围的汇总。

示例 1:

输入: [0,1,2,4,5,7]
输出: ["0->2","4->5","7"]
解释: 0,1,2 可组成一个连续的区间; 4,5 可组成一个连续的区间。
示例 2:

输入: [0,2,3,4,6,8,9]
输出: ["0","2->4","6","8->9"]
解释: 2,3,4 可组成一个连续的区间; 8,9 可组成一个连续的区间。

## 参考文章
- [LeetCode\] Summary Ranges 总结区间](https://www.cnblogs.com/grandyang/p/4603555.html)
***
## 题解
### 我的题解
```c++
class Solution {
public:
    vector<string> summaryRanges(vector<int>& nums) {
        vector<string> res;
        int i = 0, n = nums.size();
        while (i < n) {
          //i是当前区间的开头下标
            int j = 1; //j负责记录当前区间长度
            while (i + j < n && (long)nums[i + j] - nums[i] == j) ++j; //++j获取真正长度
            res.push_back(j == 1 ? to_string(nums[i]) : to_string(nums[i]) + "->" + to_string(nums[i + j - 1]));
          //分情况压入
          //to_string转字符串
            i += j;
        }
        return res;
    }
};
```

***
### 参考题解
```c++
class Solution {
public:
    vector<string> summaryRanges(vector<int>& nums) {
        if (nums.empty()) return {};
        vector<string> res;
        int l = nums[0], last = nums[0];
        for (int i = 1; i < nums.size(); ++i) {
            if (nums[i] != last + 1)
            {
                if (l == last) res.push_back(to_string(l));
                else res.push_back(to_string(l) + "->" + to_string(last));
                l = nums[i]; last = l;
            }
            else
                last = nums[i];
        }
        if (l == last) res.push_back(to_string(l));
        else res.push_back(to_string(l) + "->" + to_string(last));
        return res;
    }
};
```
## 反思

- 和to_string比，OC真的弟弟

# 217. 存在重复元素

## 题目

给定一个整数数组，判断是否存在重复元素。

如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。

示例 1:

输入: [1,2,3,1]
输出: true
示例 2:

输入: [1,2,3,4]
输出: false
示例 3:

输入: [1,1,1,3,3,4,3,2,4,2]
输出: true

## 参考文章
- [LeetCode\] Contains Duplicate 包含重复值](https://www.cnblogs.com/grandyang/p/4537029.html)
***
## 题解
### 我的题解
```c++
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        int len = nums.size();
        if (len == 0 || len == 1) {
            return false;
        }
        sort(nums.begin(), nums.end());
        for (int i = 0; i < len - 1; i++) {
            if (nums[i] == nums[i + 1]) {
                return true;
            }
        }
        return false;
    }
};
```

***
### 参考题解
```c++
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        unordered_map<int, int> m;
        for (int i = 0; i < nums.size(); ++i) {
            if (m.find(nums[i]) != m.end()) return true;
            ++m[nums[i]];
        }
        return false;
    }
};
```
## 反思

- find：在容器中搜索键值等于 k 的元素，如果找到，则返回一个指向该元素的迭代器，否则返回一个指向unordered_map :: end的迭代器。

- 使用方括号（[]），如果 k 匹配容器中某个元素的键，则该函数返回该映射值的引用，如果 k 与容器中任何元素的键都不匹配，则该函数将使用该键插入一个新元素，并返回该映射值的引用。

# 219. 存在重复元素 II

## 题目

给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。

示例 1:

输入: nums = [1,2,3,1], k = 3
输出: true
示例 2:

输入: nums = [1,0,1,1], k = 1
输出: true
示例 3:

输入: nums = [1,2,3,1,2,3], k = 2
输出: false

## 参考文章

- [219. 存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/)
***
## 题解

### 我的题解
```c++
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        int len = nums.size();
        if (len == 0 || len == 1)  {
            return false;
        }
        for (int i = 0; i < k; i++) {
            nums.push_back(INT_MAX);
        }
        for (int i = 0; i < len; i++) {
            for (int j = i + 1; j <= i + k; j++) {
                if (nums[i] == nums[j]) {
                    return true;
                }
            }
        }
        return false;
    }
};
```

***
### 参考题解
```c++
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        unordered_map<int, int> m;
        for (int i = 0; i < nums.size(); ++i) {
            if (m.find(nums[i]) != m.end() && i - m[nums[i]] <= k) 					return true;
            else m[nums[i]] = i;
        }
        return false;
    }
};
```
## 反思

- 我的想法就直白，就是跟着题目走，这里的问题在于遍历的重点，但是由于k困难会大于剩余值，极端情况就是数组长度只有3，k有4，导致无法用k去确定遍历范围
- 我的解决方法就是在数组里压了几个用不到的数据，这样就不用使用到临时变量计算k的范围了
- 但是倒数第二个测试数据多的压批，直接超时了
- 淦！这不就逼着用map吗，真的弟弟行为，这个map感觉要研究下，中午不做题目了，思考下

# 268. 缺失数字

## 题目

给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。

示例 1:

输入: [3,0,1]
输出: 2
示例 2:

输入: [9,6,4,2,3,5,7,0,1]
输出: 8
说明:
你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?

## 参考文章
- [LeetCode\] Missing Number 丢失的数字](https://www.cnblogs.com/grandyang/p/4756677.html)
***
## 题解
### 我的题解
```c++
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int res = 0;
        for (int i = 0; i < nums.size(); ++i) {
            res ^= (i + 1) ^ nums[i];
        }
        return res;
    }
};
```

***
### 参考题解
```c++
//位操作
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int res = 0;
        for (int i = 0; i < nums.size(); ++i) {
            res ^= (i + 1) ^ nums[i];
        }
        return res;
    }
};

//数组如果已经排过序 使用二分搜索
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int left = 0, right = nums.size();
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > mid) right = mid;
            else left = mid + 1;
        }
        return right;
    }
};
```
## 反思

- 位操作好神秘啊

# 238. 除自身以外数组的乘积

## 题目

给定长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。

示例:

输入: [1,2,3,4]
输出: [24,12,8,6]
说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。

进阶：
你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）

## 参考文章

- [LeetCode\] 238. Product of Array Except Self 除本身之外的数组之积](https://www.cnblogs.com/grandyang/p/4650187.html)
***
## 题解
### 我的题解
```c++
//想不通呀
//我想的是用类似于前面做的数组偏移那样，把数组偏移n - 1，每次偏移都做乘法
//但这个时间复杂度得n平方
```

***
### 参考题解
```c++
//两个辅助数组
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        vector<int> fwd(n, 1), bwd(n, 1), res(n);
        for (int i = 0; i < n - 1; ++i) {
            fwd[i + 1] = fwd[i] * nums[i];
        }
        for (int i = n - 1; i > 0; --i) {
            bwd[i - 1] = bwd[i] * nums[i];
        }
        for (int i = 0; i < n; ++i) {
            res[i] = fwd[i] * bwd[i];
        }
        return res;
    }
};

//一个res数组搞定
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int> res(nums.size(), 1);
        for (int i = 1; i < nums.size(); ++i) {
            res[i] = res[i - 1] * nums[i - 1];
        }
        int right = 1;
        for (int i = nums.size() - 1; i >= 0; --i) {
            res[i] *= right;
            right *= nums[i];
        }
        return res;
    }
};
```
## 反思

- 没有想到是要分成两部分，两个部分乘起来

# 167. 两数之和 II - 输入有序数组

## 题目
## 参考文章
- []()
***
## 题解
### 我的题解
```c++

```

***
### 参考题解
```c++

```
## 反思
# 167. 两数之和 II - 输入有序数组
## 题目
## 参考文章
- []()
***
## 题解
### 我的题解
```c++

```

***
### 参考题解
```c++

```
## 反思
# 167. 两数之和 II - 输入有序数组
## 题目
## 参考文章
- []()
***
## 题解
### 我的题解
```c++

```

***
### 参考题解
```c++

```
## 反思
# 167. 两数之和 II - 输入有序数组
## 题目
## 参考文章
- []()
***
## 题解
### 我的题解
```c++

```

***
### 参考题解
```c++

```
## 反思
# 167. 两数之和 II - 输入有序数组
## 题目
## 参考文章
- []()
***
## 题解
### 我的题解
```c++

```

***
### 参考题解
```c++

```
## 反思
# 167. 两数之和 II - 输入有序数组
## 题目
## 参考文章
- []()
***
## 题解
### 我的题解
```c++

```

***
### 参考题解
```c++

```
## 反思
# 167. 两数之和 II - 输入有序数组
## 题目
## 参考文章
- []()
***
## 题解
### 我的题解
```c++

```

***
### 参考题解
```c++

```
## 反思